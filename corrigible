#!/usr/bin/env python

import argparse
import os
import yaml
import heapq
import re
import jinja2
import copy
from jinja2 import Template

SCRIPT_DIRPATH = os.path.dirname( __file__ )
SOURCES_DIRPATH = os.path.join(SCRIPT_DIRPATH, '..')
PROVISION_ROOT_DIRPATH = os.path.join(SOURCES_DIRPATH, 'provision')

#machines_dirpath() = os.path.join(PROVISION_ROOT_DIRPATH, 'machines')
#directives_dirpath = os.path.join(PROVISION_ROOT_DIRPATH, 'directives')
#files_dirpath = os.path.join(PROVISION_ROOT_DIRPATH, 'files')

MAX_DIRECTIVE_ORDER = 9999999

jinja2.Environment(autoescape=False)


def envvar_cap_var(environment_variable_name, **kwargs):
    try:
        return os.environ[environment_variable_name]
    except KeyError:
        try:
            return kwargs['default']
        except KeyError:
            return None
    
def machines_dirpath():
    return envvar_cap_var('CORRIGIBLE_MACHINES',default='/usr/local/etc/corrigible/machines')

def directives_dirpath():
    return envvar_cap_var('CORRIGIBLE_DIRECTIVES',default='/usr/local/etc/corrigible/directives')

def files_dirpath():
    return envvar_cap_var('CORRIGIBLE_FILES',default='/usr/local/etc/corrigible/files')

_directive_filename_map = None
_directive_filepath_map = None
_directive_sortorder_map = None
def directive_filename_map():
    global _directive_filename_map
    global _directive_sortorder_map
    global _directive_filepath_map
    
    print "directive_filename_map entered"
    
    if _directive_filename_map is None:
        _directive_filename_map = []
        _directive_sortorder_map = {}
        _directive_filepath_map = {}
        directive_files_dirpath = os.path.join(os.path.dirname(__file__),
                                            '..',
                                            'provision',
                                            'directives')
        print "directive files dirpath: {}".format(directive_files_dirpath)
        for filename in os.listdir(directive_files_dirpath):
            print "listdir result: {}".format(filename)
            if os.path.isfile(os.path.join(directive_files_dirpath,filename)):
                print "examining: {}".format(filename)
                
                directive_match = re.search(r"^(\d+)\_(.*)\.directive\.yml$", filename)
                if directive_match:
                    sort_order = int(directive_match.group(1))
                    directive_name = directive_match.group(2)
                    
                    print "sort_order: {}, directive_name: {}".format(sort_order, directive_name)
                    
                    _directive_sortorder_map[directive_name] = sort_order
                    
                    
                    print "adding filepath[{}]: {}".format(directive_name, os.path.join(directive_files_dirpath, filename))
                    _directive_filepath_map[directive_name] = \
                        os.path.join(directive_files_dirpath, filename)
                    
                    heapq.heappush(_directive_filename_map,
                                   (sort_order,
                                    directive_name,
                                    os.path.join(directive_files_dirpath, filename)))
                                   
                ansible_match = re.search(r"^(\d+)\_(.*)\.ansible\.yml$", filename)
                if ansible_match:
                    sort_order = int(ansible_match.group(1))
                    directive_name = ansible_match.group(2)
                    
                    print "sort_order: {}, directive_name: {}".format(sort_order, directive_name)
                    
                    _directive_sortorder_map[directive_name] = sort_order
                    _directive_filepath_map[directive_name] = \
                        os.path.join(directive_files_dirpath, filename)
                    
                    heapq.heappush(_directive_filename_map,
                                   (sort_order,
                                    directive_name,
                                    os.path.join(directive_files_dirpath, filename)))
                    
                    
    return _directive_filename_map

def _get_directive_index(directive_name):
    global _directive_sortorder_map
    directive_filename_map()
    try:
        return _directive_sortorder_map[directive_name]
    except KeyError:
        pass

def _get_directive_filepath(directive_name):
    global _directive_filepath_map
    print "_get_directive_filepath entered (directive: {})".format(directive_name)
    directive_filename_map()
    try:
        return _directive_filepath_map[directive_name]
    except KeyError:
        pass

#def _gen_playbook():
    
    #filepath = "/tmp/provision_{}.playbook".format(machine)
    #with open(filepath, "w") as fh:
        #order, txt = \
            #_playbook_from_list(
                #directives=machine_config['directives'],
                #parameters=machine_config['parameters']
            #)
        #fh.write(txt)
                                                     ##parameters=params))
    #return filepath 

#def _gen_ansible_hostsfile():
    #filepath = "/tmp/provision_{}.hosts".format(machine)
    #hostrecs = machine_config['hosts']
    
    ## this should read the host groups from the machine config and write something appropriate
    
    #with open(filepath, "w") as fh:
        #fh.write("[all]\n")
        
        #for hostrec in hostrecs:
            #fh.write("{} ansible_ssh_host={}\n".format(hostrec['hostname'], hostrec['ip_address']))
        #fh.write("\n")
        
    #fh.close()
        

def _playbook_from_list(**kwargs):
    try:
        params = kwargs['parameters']
    except KeyError:
        params = {}
    
    try:
        retlist= []
        
        print "directives({}), parameters({})".format(kwargs['directives'], params)
        for directives_dict in kwargs['directives']:
            ordernum, playbook_text = _playbook_from_dict(directives=directives_dict,
                                                        parameters=params)
            #print "o: {}, t: {}".format(ordernum, playbook_text)
            heapq.heappush(retlist, (ordernum, playbook_text))
        
        ret = ""
        for item in sorted(retlist):
            order, txt = item
            ret += "{}\n".format(txt)
        #print "_playbook_from_list returning: ({}, {})".format(MAX_DIRECTIVE_ORDER, ret)
        return (MAX_DIRECTIVE_ORDER, ret)
    except KeyError:
        raise RequiredParameterDirectivesNotProvided()
   
def _merge_args(args_base, args_adding):
    #print "_merge_args: base({}), adding({})".format(args_base, args_adding)
    ret = copy.copy(args_base)
    for k,y in args_adding.iteritems():
        ret[k] = y
    #print "_merge_args returning {}".format(ret)
    return ret
   
class RequiredParameterDirectivesNotProvided(Exception):
    pass
   
class DirectivesDictContainedNoDirectives(Exception):
    pass
   
def _playbook_from_dict(**kwargs):
    
    try:
        params = kwargs['parameters']
    except KeyError:
        params = {}    
    
    try:
        directives_dict = kwargs['directives']
        print "directives({}), parameters({})".format(kwargs['directives'], params)
        
        try:
            params = _merge_args(params, directives_dict['parameters'])
        except KeyError:
            pass
        
        try:
            return _playbook_from_list(directives=directives_dict['directives'],
                                       parameters=params)
        except KeyError:
            
            try:
                directive_name = directives_dict['directive']
                directive_index = _get_directive_index(directive_name)
                directive_filepath = _get_directive_filepath(directive_name)
            
                try:
                    with open(directive_filepath, "r") as fh:
                        dict_yaml_text = None
                        if params:
                            #print "params!: {}".format(params)
                            initial_template_text = fh.read()
                            #print "init temp txt: {}".format(initial_template_text)
                            dict_yaml_text = Template(initial_template_text).render(params)
                            #print "cp -after"
                        else:
                            dict_yaml_text = Template(fh.read()).render()
            
                        yaml_struct = yaml.load(dict_yaml_text)
                        if type(yaml_struct) is list and len(yaml_struct) == 1:
                            yaml_struct = yaml_struct[0]
                            
                        if 'directives' in yaml_struct.keys() or \
                           'files' in yaml_struct.keys():
                            #print "calling with yaml struct"
                            return _playbook_from_dict(directives=yaml_struct, parameters=params)
                        else:
                            return (directive_index, "{}\n".format(dict_yaml_text))
                        #return (directive_index, template_text)
                except jinja2.exceptions.TemplateSyntaxError:
                    #print "ERR: Template syntax error in {}".format(directive_filepath)
                    raise
            except KeyError:
                raise DirectivesDictContainedNoDirectives
    except KeyError:
        raise RequiredParameterDirectivesNotProvided()

        
def _run_ansible_playbook(**kwargs):
    pass

def provision_machine(opts):
    #machine = machine_name

    #with open (os.path.join(machines_dirpath(), "{}.machine.yml".format(machine_name)), "r") as machine_def_str: 
        
        ## generate the playbook
        ##rendered_machine_def_str = Template(machine_def_str.read()).render(**os.environ)
        ##machine_config = yaml.load(rendered_machine_def_str)
        #tmp_ansible_hostsfile_filepath = _gen_ansible_hostsfile()
        #tmp_playbook_filepath = _gen_playbook()
        
        ## run it
    run_ansible_playbook(filepath=ansible_playbook_filepath(opts),
                         hostsfilepath=ansible_hostsfile_filepath(opts))

machine_conf = None
def machine_config(opts):
    global machine_conf
    try:
        if machine_conf is None:
            machine_name = opts["machine"]
            machine_config_filepath = os.path.join(machines_dirpath(), "{}.meta".format(machine_name))
            print "INFO: loading machine config for: {}, at {}".format(machine_name, machine_config_filepath)
            with open (machine_config_filepath, "r") as machine_def_fh: 
                rendered_machine_def_str = Template(machine_def_fh.read()).render(**os.environ)
                machine_conf = yaml.load(rendered_machine_def_str)
    except IOError:
        print "\nERR: machine config not found at: {}, machine_config will be None\n".format(machine_config_filepath)
    return machine_conf
    

def machine_name(opts):
    return opts["machine"]

def ansible_hostsfile_filepath(opts):
    try:
        return opts["hosts_output_file"]
    except KeyError:
        return "/tmp/provision_{}.hosts".format(machine_name(opts))

def ansible_playbook_filepath(opts):
    try:
        return opts["playbook_output_file"]
    except KeyError:
        return "/tmp/provision_{}.playbook".format(machine_name(opts))

def write_ansible_hosts(opts):
    try:
        mconf = machine_config(opts)
        hostrecs = mconf['hosts']
        
        with open(ansible_hostsfile_filepath(opts), "w") as fh:
            fh.write("[all]\n")
            
            for hostrec in hostrecs:
                fh.write("{} ansible_ssh_host={}\n".format(hostrec['hostname'], hostrec['ip_address']))
            fh.write("\n")
    except TypeError:
        print "machine_config: {}".format(str(mconf))
        if mconf is None:
            print "ERR: No machine config, not writing ansible hosts file"
            return
        else:
            raise
        
        
    # this should read the host groups from the machine config and write something appropriate
    
    

def write_ansible_playbook(opts):
    try:
        mconf = machine_config(opts)
        
        try:
            directives = mconf['directives']
        except KeyError:
            directives = {}
            
        try:
            params = mconf['parameters']
        except KeyError:
            params = {}
            
        playbook_output_filepath = ansible_playbook_filepath(opts)
        print "INFO: writing ansible playbook data to {}".format(playbook_output_filepath)
        with open(ansible_playbook_filepath(opts), "w") as fh:
            order, txt = _playbook_from_list( directives=directives, parameters=params )
            if bool(txt):
                fh.write(txt)
            else:
                fh.write("# WARN: No directives found!\n")
            
    except TypeError:
        #print "machine_config: {}".format(str(mconf))
        if mconf is None:
            print "ERR: No machine config, not writing ansible playbook file"
            return
        else:
            raise
        

if __name__ == '__main__':

    # --- command-line options, crawl params
    # ---------------------------------------------------------------
    parser = argparse.ArgumentParser(
        description='provision a server.',
        prog='corrigible'
    )
    
    progargs = ( ( "machine", "positional", "the name of the machine (or group) whose config will be parsed" ),
                 ( "playbook-output-file", "full", "the playbook output file (for testing, use discouraged)"),
                 ( "hosts-output-file", "full", "the hosts output file (for testing, use discouraged)"),
                 ( "generate-files-only", "short", "this flag tells corrigible to take no action, but only generate the files" ) )
    
    for arginfo in progargs:
        optname, opttype, opthelp = arginfo
        if opttype == "positional":
            parser.add_argument(optname, help=opthelp)
        elif opttype == "short":
            parser.add_argument("--{}".format(optname), help=opthelp, action="store_true") 
        elif opttype == "full":
            parser.add_argument("--{}".format(optname), help=opthelp) 
    
    args = vars(parser.parse_args())
    options = {}
    for opt, val in args.iteritems():
        options[opt] = val
    
    #options = vars(parser.parse_args())
    write_ansible_hosts(options)
    write_ansible_playbook(options)
    
    #print "options: {}".format(str(options))
    
    #print "opt[generate-files-only]: {}".format(options['generate_files_only'])
    
    if not options["generate_files_only"]:
        provision_machine(options)
    